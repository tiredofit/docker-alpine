#!/command/with-contenv bash

source /assets/defaults/00-container

# Background Colors
bdg="\e[42m"       # Background Color Dark Green
bdb="\e[44m"       # Background Color Dark Blue
bdm="\e[45m"       # Background Color Dark Magenta
bdgy="\e[100m"     # Background Color Dark Gray
blr="\e[101m"      # Background Color Light Red
boff="\e[49m"      # Background Color Off


check_container_initialized() {
    ### Check to see Initialization Script ran
    print_debug "Checking to see if container initialization scripts have completed"
    output_off
    while [ ! -f /tmp/.container/99-container-init ]; do
        print_debug "Checking to see if container initialization scripts have completed"
        sleep 1
    done
    output_on
}

check_service_initialized() {
    ## Usage:
    ## check_service_initialized init: Look for the matching filename of /etc/services.available/<folder-name> in /tmp/.container/<folder-name>-init
    ## ## check_service_initialized <service folder> Look for the matching filename of /etc/services.available/<folder-name> in /tmp/.container/<folder-name>
    ## Related to liftoff function, which writes /tmp/.container/script|foldername
    ## Scripts that run in /etc/cont-init.d get an -init at the end of their filename
    ## Scripts that run from /etc/services.available/* just get the foldername without any suffix
    print_debug "Checking to see if service has initialized"
    output_off
    if [ "$1" = "init" ]; then
        service_suffix="-init"
        csi_bypass=FALSE
    else
        service="$1"
        csi_bypass=TRUE
    fi

    if [ "$csi_bypass" = "FALSE" ] ; then
        if [ -z "$2" ]; then
            case "$(dirname "$0")" in
                "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                    service=$(basename "$0")
                ;;
                *)
                    service=$(basename "$PWD")
                ;;
            esac
        else
            service=$2
        fi
    fi

    while [ ! -f /tmp/.container/"${service}"${service_suffix} ]
    do
        sleep 1
        print_debug "Looking for existence of /tmp/.container/${service}${service_suffix}"
    done
    unset csi_bypass
    output_on
}

clone_git_repo() {
    ## Cut down on the space and size required to clone a repository if you are pulling a specific tag or branch
    ## Usage: clone_git_repo https://github.com/maintainer/repo <branch/tag/commit> <custom_dest>
    ## It will automatically create a folder in /usr/src/<repo name> eg repo and also expose a variable called GIT_REPO_SRC and GIT_REPO_SRC_<REPONAME> in caps
    ## Any special characters get removed other than numbers and letters
    set +x
    if [ ${DEBUG_MODE,,} = "true" ] ; then set -x ; fi
    if ! [ -x "$(command -v git)" ]; then
        echo '[clone_git_repo] Git is not installed'
        exit 1
    else
        git config --global init.defaultBranch main
    fi

    if [ -n "$1" ] ; then
        if [ -n "${3}" ] ; then
            repo="${3}/"
            repo_text="to '${3}'"
            repo_name="$(echo ${1,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
        else
            repo="/usr/src/$(echo ${1,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
            repo_name="$(echo ${1,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
        fi

        export GIT_REPO_SRC=${GIT_REPO_SRC:-"${repo}"}
        export GIT_REPO_SRC_${repo_name^^}="${repo}"
        if [ -d "${repo}" ] ; then
            echo "[clone_git_repo] Directory ${repo_path}${repo} already exists. Cannot clone"
            exit 1
        else
            if [[ $1 == *".git" ]] ; then
                :
            else
                append_git_prefix=".git"
            fi

            mkdir -p "${repo}"
            cd "${repo}"
            git init .
            git remote add origin "${1}"${append_git_prefix}
            if [ -n "${2}" ] ; then repo_commit="${2}" ; fi
            echo "[clone_git_repo] Cloning Git Repo '${1}' '${2}' ${repo_text}"
            git fetch --depth=1 origin ${2} +refs/tags/*:refs/tags/*
            git fetch --depth 1 origin ${2}
            git -c advice.detachedHead=false checkout FETCH_HEAD
            git submodule update --init
        fi
    else
        echo "[clone_git_repo] You tried to call the function but there's no arguments"
        exit 1
    fi
    set -x
}

create_logrotate() {
    ## Usage <Logrotate Config Name> <path> (optional logship parser) (optional user) (optional group)
    ## e.g. create_logrotate cron /var/log/cron/cron.log cron root root
    ## If you dont have a parser just use 'none'
    ## If you are passing wilcard characters ie /logs/*.log make sure you 'set -f' before the function and 'set +f' afterwards.

    if [ -n "$1" ] && [ -n "$2" ]; then
        if [ ! -f /assets/logrotate/"$1" ] ; then
            print_debug "Creating Logrotate Entry for $2"
            if [ -n "$3" ] ; then
                if [ "${3,,}" != "none" ] ; then
                    lrlsparser="# logship: $3"
                fi
            fi
            if [ -n "$4" ] && [ -n "$5" ]; then
                lruser="    su $4 $5"
            fi

            if [ ! -d "/assets/logrotate" ] ; then
                mkdir -p /assets/logrotate
            fi

            cat <<EOF > /assets/logrotate/"${1}"
${lrlsparser}
$2 {
    missingok
${lruser}
}
EOF
            chown root:root /assets/logrotate/"${1}"
            chmod 0644 /assets/logrotate/"${1}"
        else
            print_debug "Skipping creating automatic logrotation for ${1}"
        fi
    fi
}

create_zabbix() {
    ## Usage <Zabbix configuration name> (optional custom Autoregister name)
    ## e.g. create_zabbix cron
    ## If you dont put an autoregister argument it will just use the Configuration Name

    if [ -n "$1" ] ; then
        if [ -n "$2" ] ; then
            autoregister=$2
        else
            autoregister=$1
        fi
        print_debug "Adding Zabbix Auto Register configuration for '$1'"
        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            source /assets/defaults/03-monitoring
            cat <<EOF > "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}.d"/tiredofit_"$1".conf
# Zabbix $1 Configuration - Automatically Generated
# Autoregister=$autoregister
EOF
        fi
    fi
}

custom_files() {
    ## Copy files from one lcoation to somewhere else on the file system
    ## eg. Copy all files in /assets/custom (Default ENV CONTAINER_CUSTOM_PATH) to /www/html  'custom_files /www/html'
    ## Add another parameter if you want to move any source folder to a destination ie `custom_files /assets/customfolder2/ /destination`
    ## The third and fourth parameters if exist will change ownership to the user:group
    if [ -n "${2}" ] ; then
        ccustom_files_source="${1}"
        ccustom_files_destination="${2}"
    else
        ccustom_files_source="${CONTAINER_CUSTOM_PATH}"
        ccustom_files_destination="${1}"
    fi

    if [ -d "${ccustom_files_source}" ] && dir_notempty "${ccustom_files_source}" ; then
        print_debug "Custom Files: Copying files from '${ccustom_files_source}' to '${ccustom_files_destination}'"
        if [ -d "${ccustom_files-destination}" ] ; then
            mkdir -p "${ccustom_files-destination}"
        fi
        cp -aR "${ccustom_files_source}"/* "${ccustom_files_destination}"/
    fi

    if [ -n "${3}" ] ; then permbuilder="${3}" ; fi
    if [ -n "${4}" ] ; then permbuilder="${3}:${4}" ; fi
    if [ -n "${permbuilder}" ] ; then chown -R "${permbuilder}" "${2}" ; fi
}

custom_scripts() {
    ## Execute Custom scripts out of this directory
    if [ -n "${1}" ] ; then
        ccustom_scripts_source="${1}"
    else
        ccustom_scripts_source="${CONTAINER_CUSTOM_SCRIPTS_PATH}"
    fi

    if [ -d "${ccustom_scripts_source}" ] && dir_notempty "${ccustom_scripts_source}" ; then
        for ccustom_script in "${ccustom_scripts_source}"/*.sh ; do
            if [ -x "$ccustom_script" ] && [ ! -d "$ccustom_script" ] ; then
                print_debug "Custom Script executing: '${ccustom_script}'"
                ${ccustom_script}
            fi
        done
    fi
}

db_ready() {
    ## Usage db_ready <dbtype>
    output_off
    print_debug "Checking to see if Database Type $1 is ready"
    case "${1,,}" in
        "couch" | "couchdb" )
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ] ; then couch_port=${DB_PORT} ; fi ;
            transform_file_var COUCHDB_PORT
            if [ -n "${COUCHDB_PORT}" ] ; then couch_port=${COUCHDB_PORT} ; fi ;
            couch_port=${couch_port:-5984}
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ] ; then couch_host=${DB_HOST} ; fi ;
            transform_file_var COUCHDB_HOST
            if [ -n "${COUCHDB_HOST}" ] ; then couch_host=${COUCHDB_HOST} ; fi ;
            counter=0
            # shellcheck disable=SC2086
            while ! (nc -z "${couch_host}" ${couch_port}) ; do
                sleep 5
                (( counter+=5 ))
                print_warn "CouchDB Host '${couch_host}' is not accessible, retrying.. ($counter seconds so far)"
            done
        ;;
        "influx" | "influxdb" )
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ] ; then influx_port=${DB_PORT} ; fi ;
            transform_file_var INFLUXDB_PORT
            if [ -n "${INFLUXDB_PORT}" ] ; then influx_port=${INFLUXDB_PORT} ; fi ;
            influx_port=${influx_port:-8088}
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ] ; then influx_host=${DB_HOST} ; fi ;
            transform_file_var INFLUXDB_HOST
            if [ -n "${INFLUXDB_HOST}" ] ; then influx_host=${INFLUXDB_HOST} ; fi ;
            counter=0
            while ! (nc -z "${influx_host}" "${influx_port}") ; do
                sleep 5
                (( counter+=5 ))
                print_warn "InfluxDB Host '${influx_host}' is not accessible, retrying.. ($counter seconds so far)"
            done
        ;;
        "mongo" | "mongodb" )
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ] ; then mongo_port=${DB_PORT} ; fi ;
            transform_file_var MONGO_PORT
            if [ -n "${MONGO_PORT}" ] ; then mongo_port=${MONGO_PORT} ; fi ;
            mongo_port=${mongo_port:-27017}
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ] ; then mongo_host=${DB_HOST} ; fi ;
            transform_file_var MONGO_HOST
            if [ -n "${MONGO_HOST}" ] ; then mongo_host=${MONGO_HOST} ; fi ;
            counter=0
            while ! (nc -z "${mongo_host}" "${mongo_port}") ; do
                sleep 5
                (( counter+=5 ))
                print_warn "Mongo Host '${mongo_host}' is not accessible, retrying.. ($counter seconds so far)"
            done
        ;;
        "mysql" | "mariadb" )
            if command -v "mariadb-admin" &> /dev/null ; then
                mysqladmin_bin="$(which mariadb-admin)"
            elif command -v "mysqladmin" &> /dev/null ; then
                mysqladmin_bin="$(which mysqladmin)"
            else
                print_error "No MySQL or MariaDB client detected - Cannot check for Database"
                exit 1
            fi
            if [ ! -f /etc/my.cnf.d/disable-ssl.cnf ] ; then
                cat <<EOF > /etc/my.cnf.d/disable-ssl.cnf
[client]
ssl=FALSE
EOF
            fi
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ] ; then maria_port=${DB_PORT} ; fi ;
            transform_file_var MYSQL_PORT
            if [ -n "${MYSQL_PORT}" ] ; then maria_port=${MYSQL_PORT} ; fi ;
            transform_file_var MARIA_PORT
            if [ -n "${MARIA_PORT}" ] ; then maria_port=${MARIA_PORT} ; fi ;
            maria_port=${maria_port:-3306}
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ] ; then maria_host=${DB_HOST} ; fi ;
            transform_file_var MYSQL_PORT
            if [ -n "${MYSQL_HOST}" ] ; then maria_host=${MYSQL_HOST} ; fi ;
            transform_file_var MARIA_PORT
            if [ -n "${MARIA_HOST}" ] ; then maria_host=${MARIA_HOST} ; fi ;
            transform_file_var DB_USER
            if [ -n "${DB_USER}" ] ; then maria_user=${DB_USER} ; fi ;
            transform_file_var MYSQL_USER
            if [ -n "${MYSQL_USER}" ] ; then maria_user=${MYSQL_USER} ; fi ;
            transform_file_var MARIA_USER
            if [ -n "${MARIA_USER}" ] ; then maria_user=${MARIA_USER} ; fi ;
            transform_file_var DB_PASS
            if [ -n "${DB_PASS}" ] ; then maria_pass=${DB_PASS} ; fi ;
            transform_file_var MYSQL_PASS
            if [ -n "${MYSQL_PASS}" ] ; then maria_pass=${MYSQL_PASS} ; fi ;
            transform_file_var MARIA_PASS
            if [ -n "${MARIA_PASS}" ] ; then maria_pass=${MARIA_PASS} ; fi ;
            transform_file_var DB_NAME
            if [ -n "${DB_NAME}" ] ; then maria_name=${DB_NAME} ; fi ;
            transform_file_var MYSQL_NAME
            if [ -n "${MYSQL_NAME}" ] ; then maria_name=${MYSQL_NAME} ; fi ;
            transform_file_var MARIA_NAME
            if [ -n "${MARIA_NAME}" ] ; then maria_name=${MARIA_NAME} ; fi ;
            counter=0
            while ! ("${mysqladmin_bin}" -u"${maria_user}" -P"${maria_port}" -h"${maria_host}" -p"${maria_pass}" status > /dev/null 2>&1) ; do
                sleep 5
                (( counter+=5 ))
                print_warn "MySQL/MariaDB Server '${maria_host}' is not accessible, retrying.. (${counter} seconds so far)"
            done
        ;;
        "pgsql" | "psql" | "postgres" | "postgresql" )
            if command -v "pg_isready" &> /dev/null ; then
                pg_isready_bin="$(which pg_isready)"
            else
                print_error "No Postgresql client installation installation detected - Cannot check for Database"
                exit 1
            fi
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ] ; then postgres_port=${DB_PORT} ; fi ;
            transform_file_var POSTGRES_HOST
            if [ -n "${POSTGRES_PORT}" ] ; then postgres_port=${POSTGRES_PORT} ; fi ;
            postgres_port=${postgres_port:-5432}
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ] ; then postgres_host=${DB_HOST} ; fi ;
            transform_file_var POSTGRES_HOST
            if [ -n "${POSTGRES_HOST}" ] ; then postgres_host=${POSTGRES_HOST} ; fi ;
            transform_file_var DB_USER
            if [ -n "${DB_USER}" ] ; then postgres_user=${DB_USER} ; fi ;
            transform_file_var POSTGRES_USER
            if [ -n "${POSTGRES_USER}" ] ; then postgres_user=${POSTGRES_USER} ; fi ;
            transform_file_var DB_PASS
            if [ -n "${DB_PASS}" ] ; then postgres_pass=${DB_PASS} ; fi ;
            transform_file_var PGPASSWORD
            if [ -n "${PGPASSWORD}" ] ; then postgres_pass=${PGPASSWORD} ; fi ;
            transform_file_var DB_NAME
            if [ -n "${DB_NAME}" ] ; then postgres_name=${DB_NAME} ; fi ;
            transform_file_var POSTGRES_NAME
            if [ -n "${POSTGRES_NAME}" ] ; then postgres_name=${POSTGRES_NAME} ; fi ;
            counter=0
            export PGPASSWORD=${postgres_pass}
            until "${pg_isready_bin}" --dbname="${postgres_name}" --host="${postgres_host}" --port="${postgres_port}" --username="${postgres_user}" -q
            do
                sleep 5
                (( counter+=5 ))
                print_warn "Postgres Host '${postgres_host}' is not accessible, retrying.. ($counter seconds so far)"
            done
        ;;
        "rabbit" | "rabbitmq" )
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ] ; then rabbit_port=${DB_PORT} ; fi ;
            transform_file_var RABBIT_PORT
            if [ -n "${RABBIT_PORT}" ] ; then rabbit_port=${RABBIT_PORT} ; fi ;
            rabbit_port=${rabbit_port:-5672}
            transform_file_var DB_HOST
            if [ -n "${DB_HOST}" ] ; then rabbit_host=${DB_HOST} ; fi ;
            transform_file_var RABBIT_HOST
            if [ -n "${RABBIT_HOST}" ] ; then rabbit_host=${RABBIT_HOST} ; fi ;
            counter=0
            while ! (nc -z "${rabbit_host}" "${rabbit_port}") ; do
                sleep 5
                (( counter+=5 ))
                print_warn "RabbitMQ Host '${rabbit_host}' is not accessible, retrying.. ($counter seconds so far)"
            done
        ;;
        "redis" )
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ] ; then redis_port=${DB_PORT} ; fi ;
            if [ -n "${DB_PORT_FILE}" ] ; then couch_port="$(cat "${DB_PORT_FILE}")" ; fi ;
            if [ -n "${REDIS_PORT}" ] ; then redis_port=${REDIS_PORT} ; fi ;
            redis_port=${redis_port:-6379}
            if [ -n "${DB_HOST}" ] ; then redis_host=${DB_HOST} ; fi ;
            if [ -n "${REDIS_HOST}" ] ; then redis_host=${REDIS_HOST} ; fi ;
            counter=0
            while ! (nc -z "${redis_host}" "${redis_port}") ; do
                sleep 5
                (( counter+=5 ))
                print_warn "Redis Host '${redis_host}' is not accessible, retrying.. ($counter seconds so far)"
            done
        ;;
        "rethink" )
            transform_file_var DB_PORT
            if [ -n "${DB_PORT}" ] ; then rethink_port=${DB_PORT} ; fi ;
            if [ -n "${DB_PORT_FILE}" ] ; then couch_port="$(cat "${DB_PORT_FILE}")" ; fi ;
            if [ -n "${RETHINK_PORT}" ] ; then rethink_port=${RETHINK_PORT} ; fi ;
            rethink_port=${rethink_port:-28015}
            if [ -n "${DB_HOST}" ] ; then rethink_host=${DB_HOST} ; fi ;
            if [ -n "${RETHINK_HOST}" ] ; then rethink_host=${RETHINK_HOST} ; fi ;
            counter=0
            while ! (nc -z "${rethink_host}" "${rethink_port}") ; do
                sleep 5
                (( counter+=5 ))
                print_warn "RethinkDB Host '${DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
            done
        ;;
    esac
    output_on
}

dir_empty() {
    [ ! -n "$(ls -A "$1" 2>/dev/null)" ]
}

dir_notempty() {
    [ -n "$(ls -A "$1" 2>/dev/null)" ]
}

file_env() {
    ## Docker Secrets Support
    ## usage: file_env VAR [DEFAULT]
    ##    ie: file_env 'XYZ_DB_PASSWORD' 'example'
    ##        (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature)
    if [ "${CONTAINER_ENABLE_DOCKER_SECRETS,,}" = "true" ] ; then
        local var="$1"
        local fileVar="${var}_FILE"
        local def="${2:-}"
        local val="$def"
        if [ "${!fileVar:-}" ]; then
            val="$(cat "${!fileVar}")"
            elif [ "${!var:-}" ]; then
            val="${!var}"
        fi

        if [ -z "${val}" ]; then
            print_error "error: neither $var nor $fileVar are set but are required"
            exit 1
        fi
        export "$var"="$val"
        unset "$fileVar"
    fi
}

get_defaults() {
    ## Get Defaults
    ## Usage: get_defaults <option>
    ##      Option: all - Load all default files from /assets/defaults folder
    ##      Option: app | single - Load existing scripts defaults from /assets/defaults (e.g. If cont-init.d/10-app is running load 10-app from defaults)
    ##      Option: 10-app,11-app,12-app - Load in Sequence all of these Default Files from /assets/defaults/
    ##         Leaving option blank will load all files from the /assets/defaults folder
    if [ -n "$1" ] ; then
        case "${1,,}" in
            "all" )
                for d in /assets/defaults/* ; do
                    print_debug "Container: Getting defaults for '${d}' ALL"
                    # shellcheck source=/assets/defaults/
                    case "$(basename "${d}")" in
                        0*-* | 99-* )
                            output_off
                            source "${d}"
                            output_on
                        ;;
                        * )
                            source "${d}"
                        ;;
                    esac
                done
            ;;
            "app" | "single" )
                case "$(dirname "$0")" in
                    "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                        if [ -f "/assets/defaults/$(basename "$0")" ] ; then
                            print_debug "Container: Getting defaults for '$(basename "$0")'"
                            # shellcheck source=/assets/defaults/
                            case "$(basename "$0")" in
                                0*-* | 99-* )
                                    output_off
                                    source /assets/defaults/"$(basename "$0")"
                                    output_on
                                ;;
                                * )
                                    source /assets/defaults/"$(basename "$0")"
                                ;;
                            esac
                        else
                            print_debug "Container: No defaults available for '$(basename "$0")'"
                        fi
                    ;;
                    *)
                        if [ -f "/assets/defaults/$(basename "$PWD")" ] ; then
                            print_debug "Container: Getting defaults for '$(basename "$PWD")'"
                            # shellcheck source=/assets/defaults/
                            case "$(basename "$PWD")" in
                                0*-* | 99-* )
                                    output_off
                                    source /assets/defaults/"$(basename "$PWD")"
                                    output_on
                                ;;
                                * )
                                    source /assets/defaults/"$(basename "$PWD")"
                                ;;
                            esac
                        else
                            print_debug "Container: No defaults available for $(basename "$PWD")"
                        fi
                    ;;
                esac
            ;;
            * )
                defaults=$(echo "$1" | tr "," "\n")
                for d in $defaults; do
                    if [ -f "/assets/defaults/${d}" ] ; then
                        print_debug "Container: Getting defaults for $d"
                        # shellcheck source=/assets/defaults/
                        case "${d}" in
                            0*-* | 99-* )
                                output_off
                                source /assets/defaults/"${d}"
                                output_on
                            ;;
                            * )
                                source /assets/defaults/"${d}"
                            ;;
                        esac
                    else
                        print_debug "Container: No defaults available for '${d}'"
                    fi
                done
            ;;
        esac
    else
        for d in /assets/defaults/* ; do
            print_debug "Container: Getting defaults for $d"
            # shellcheck source=/assets/defaults/
            case "$(basename "${d}")" in
                0*-* | 99-* )
                    output_off
                    source /assets/defaults/00-container
                    source "${d}"
                    output_on
                ;;
                * )
                    source /assets/defaults/00-container
                    source "${d}"
                ;;
            esac
        done
    fi
}

get_functions() {
    ## Usage: get_functions <option>
    ## Option: all - Load all default files from /assets/functions folder
    ## Option: app | single - Load existing scripts defaults from /assets/functions (e.g. If cont-init.d/10-app is running load 10-app from functions)
    ## Option: 10-app,11-app,12-app - Load in Sequence all of these Default Files from /assets/functions/
    ## Leaving option blank will load all files from the /assets/functions folder
    if [ -n "$1" ] ; then
        case "${1,,}" in
            "all" )
                for f in /assets/functions/* ; do
                    if [ "$f" != "/assets/functions/00-container" ] ; then
                        print_debug "Container: Getting functions for '${f}'"
                        # shellcheck source=/assets/functions/
                        source "$f"
                    fi
                done
            ;;
            "app" | "single" )
                case "$(dirname "$0")" in
                    "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                        if [ -f "/assets/functions/$(basename "$0")" ] ; then
                            print_debug "Container: Getting functions for '$(basename "$0")'"
                            # shellcheck source=/assets/functions/
                            source /assets/functions/"$(basename "$0")"
                        else
                            print_debug "Container: No functions available for '$(basename "$0")'"
                        fi
                    ;;
                    *)
                        if [ -f "/assets/functions/$(basename "$PWD")" ] ; then
                            print_debug "Container: Getting functions for '$(basename "$PWD")'"
                            # shellcheck source=/assets/functions/
                            source /assets/functions/"$(basename "$PWD")"
                        else
                            print_debug "Container: No functions available for $(basename "$PWD")"
                        fi
                    ;;
                esac
            ;;
            * )
                functions=$(echo "$1" | tr "," "\n")
                for f in $functions; do
                    if [ -f "/assets/functions/${f}" ] ; then
                        print_debug "Container: Getting functions for $f"
                        # shellcheck source=/assets/functions/
                        source /assets/functions/"${f}"
                    else
                        print_debug "Container: No functions available for '$f'"
                    fi
                done
            ;;
        esac
    else
        for f in /assets/functions/* ; do
            if [ "$f" != "/assets/functions/00-container" ] ; then
                print_debug "Container: Getting functions for $f"
                # shellcheck source=/assets/functions/
                source "${f}"
            fi
        done
    fi
}

get_image_version() {
    output_off
    if [ -n "${IMAGE_NAME}" ] ; then
        if [ -f "/assets/.changelogs/${IMAGE_NAME/\//_}.md" ] ; then
            image_version=$(head -n1 /assets/.changelogs/${IMAGE_NAME/\//_}.md | awk '{print $2}')
            elif [ -f /assets/.changelogs/docker-${IMAGE_NAME/\//_}.md ] ; then
            image_version=$(head -n1 /assets/.changelogs/docker-${IMAGE_NAME/\//_}.md | awk '{print $2}')
        else
            if [ -f /assets/.changelogs/tiredofit_docker-${IMAGE_NAME/\//_}.md ] ; then
                image_version=$(head -n1 /assets/.changelogs/docker-${IMAGE_NAME/\//_}.md | awk '{print $2}')
            else
                strip_image_repo_url=$(echo ${IMAGE_REPO_URL%/} | sed "s#https://github.com/##g")
                if [ -f /assets/.changelogs/${strip_image_repo_url/\//_}.md ] ; then
                    image_version=$(head -n1 /assets/.changelogs/${strip_image_repo_url/\//_}.md | awk '{print $2}')
                fi
            fi

            if [ -f /assets/.changelogs/tiredofit_docker-${IMAGE_NAME/\//_}.md ] ; then
                image_version=$(head -n1 /assets/.changelogs/tiredofit_docker-${IMAGE_NAME/\//_}.md | awk '{print $2}')
            fi
        fi

        if [ -n "${image_version}" ] ; then
            echo "${image_version}"
        fi
    fi
    output_on
}

grant_doas() {
    ## Grant doas priveleges to a user
    ## grant_doas (username) (command) | If no command set will be ALL
    output_off
    if [ -n "$1" ] ; then
        print_debug "Adding Doas privileges to '$1'"
        if [ -n "$2" ] ; then
            print_debug="Adding doas privileges to '$1' for '${doas_command}' command"
            doas_command="cmd $2"
        else
            doas_command=""
        fi

        echo "permit nopass $1 ${doas_command} as root" >> /etc/doas.conf
        chown root:root /etc/doas.conf
        chmod 0400 -R /etc/doas.conf
    fi
    output_on
}

grant_sudo() {
    ## 2022-02-07 Will be deprecated in future releases. Use "grant_doas" instead
    ## Grant sudo priveleges to a user
    ## grant_sudo (username) (command) | If no command set will be ALL
    output_off
    if [ -n "$1" ] ; then
        if [ -n "$2" ] ; then
            sudo_command="$2"
        else
            sudo_command="ALL"
        fi
        print_debug "Adding Sudo privileges to '$1' for '${sudo_command}' command"
        echo "%$1 ALL=(ALL) NOPASSWD:${sudo_command}" >> /etc/sudoers
    fi
    output_on
}

host_override() {
    ## Adds entry to /etc/hosts file
    ## Usage CONTAINER_HOST_OVERRIDE01=destination_ip domain1 domain2 domain3
    ## If you use a host name instead of destination_ip it will attempt to resolve it
    _hostnum=$(printenv | sort | grep -cE '^CONTAINER_HOST_OVERRIDE_([0-9].)')
    for (( _host = 01; _host <= _hostnum; _host++ )) ; do
        _host=$(printf "%02d" $_host)
        host_line=CONTAINER_HOST_OVERRIDE_${_host}
        host_ip=$(echo ${!host_line} | awk '{print $1}')

        if [[ ! "${host_ip}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            host_ip="$(getent ahostsv4 "${host_ip}" | grep -m 1 STREAM  | awk '{print $1}')"
        fi

        echo "# Added automatically by CONTAINER_HOST_OVERRIDE_${_host}" >> /etc/hosts
        echo "${host_ip} $(echo ${!host_line} | cut -d' ' -f2-)" >> /etc/hosts
    done
}

install_template() {
    ## Copies configuration template to the destination as the specified USER
    ## Usage install_template <copy-as-user> <source_file> <desintation_location+file> <optional chmod mode>

    if [ -z "$1" ] || [ -z $2 ] || [ -z $3 ] ; then
        print_error "[install_tempalte] No arguments passed"
        exit 1
    fi

    local template_mode=${4:-"0644"}
    if [ ! -f "$2" ]; then
        print_error "[install_template] Can't find ${2}"
        exit 1
    fi

    if [ ! -d "$(dirname $3)" ] ; then
        mkdir -p "$(dirname $3)"
    fi

    chmod "${template_mode}" "${3}"
    chown "${1}" "${DEST}"
}

log_prefix() {
    output_off
    if [ "${CONTAINER_ENABLE_LOG_PREFIX,,}" = "true" ] ; then
        echo "$(date +"${CONTAINER_LOG_PREFIX_DATE_FMT}")${CONTAINER_LOG_PREFIX_SEPERATOR}$(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") "
    fi
    output_on
}


liftoff() {
    ## For writing script initalization state to ensure proper application execution
    output_off
    mkdir -p /tmp/.container
    if [ "$DONOTSTART" = "TRUE" ]; then
        liftoff_prefix="DONOTSTART "
    fi
    case "$(dirname "$0")" in
        "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
            echo "${liftoff_prefix} $(basename "$0")-init initialized on $(log_prefix)" >> /tmp/.container/"$(basename "$0")"-init
        ;;
        *)
            if [ ! -f /tmp/.container/"$(basename "$PWD")" ]; then
                echo "$(basename "$PWD") initialized on $(log_prefix)" >> /tmp/.container/"$(basename "$PWD")"
            else
                echo "$(basename "$PWD") reinitialized on $(log_prefix)" >> /tmp/.container/"$(basename "$PWD")"
            fi
        ;;
    esac
    output_on
}


output_off() {
    ## An attempt to shut down so much noise in the log files, specifically for echo statements
    if [ "${DEBUG_MODE,,}" = "true" ] ; then
        set +x
    fi
}

output_on() {
    if [ "${DEBUG_MODE,,}" = "true" ] ; then
        case "$(basename "$0")" in
            0*-* | 99-* )
                :
            ;;
            run )
                case "$PWD" in
                    */0*-* | 99-* )
                        :
                    ;;
                    * )
                        set -x
                    ;;
                esac
            ;;
            * )
                set -x
            ;;
        esac
    fi
}

package() {
    cleanup() {
        case "${distro}" in
            "alpine" )
                rm -rf /root/.gitconfig
                rm -rf /var/cache/apk/*
            ;;
            "debian" | "ubuntu" )
                apt-get clean -y
                rm -rf /root/.gitconfig
                rm -rf /var/lib/apt/lists/*
            ;;
        esac
    }

    install() {
        case "${distro}" in
            "alpine" )
                if [[ "${1}" =~ ^\..* ]] ; then
                    local dependencies="-t"
                fi
                apk add ${dependencies} $@
            ;;
            "debian" | "ubuntu" )
                if [[ "${1}" =~ ^\..* ]] ; then
                    shift
                fi
                apt-get install -y --no-install-recommends $@
            ;;
        esac
    }

    remove() {
        case "${distro}" in
            "alpine" )
                apk del $@
            ;;
            "debian" | "ubuntu" )
                local packages="$@"
                if [[ "${packages}" =~ \..* ]] ; then
                    packages=$(echo "${packages}" | sed "s|\..* ||g")
                fi
                apt-get purge -y ${packages}
                apt-get autoremove -y
            ;;
        esac
    }

    update() {
        case "${distro}" in
            "alpine" )
                apk update
            ;;
            "debian" | "ubuntu" )
                apt-get update
            ;;
        esac
    }

    upgrade() {
        case "${distro}" in
            "alpine" )
                apk upgrade
            ;;
            "debian" | "ubuntu" )
                apt-get upgrade -y
            ;;
        esac
    }

    output_off
    local distro
    distro=$(cat /etc/os-release |grep ^ID= | cut -d = -f2)
    local action="${1}"
    shift
    local arguments=$@

    case "${action}" in
        add | install )
            action=install
            "${action}" "${arguments}"
        ;;
        delete | remove | uninstall )
            action=remove
            "${action}" "${arguments}"
        ;;
        * )
            "${action}" "${arguments}"
        ;;
    esac
    output_on
}

prepare_service() {
    ## Prepare Service by loading defaults and functions
    ## Relies on get_defaults and get_functions above in script
    ## Usage: prepare_service <options>
    ## By default if script is running before container has initialized then both defaults and functions are loaded
    ## If running outside of /etc/cont-init.d pass 'defaults' or 'functions' to only load specific types (Useful when not wanting to load the entire function file in /etc/services.d)
    if [ -n "$1" ] ; then
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
                set -a
                get_defaults "$1"
                get_functions "$1"
                set +a
            ;;
            *)
                case "$1" in
                    "BOTH" | "both" | "ALL" | "all" )
                        get_defaults "$2"
                        get_functions "$2"
                    ;;
                    "DEFAULTS" | "defaults" )
                        get_defaults "$2"
                    ;;
                    "FUNCTIONS" | "functions" )
                        get_functions "$2"
                    ;;
                esac
            ;;
        esac
    else
        case "$(dirname "$0")" in
            "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
                set -a
                get_defaults
                get_functions
                set +a
            ;;
            *)
                get_defaults
            ;;
        esac
    fi
}


print_debug() {
    ### Text Coloration
    output_off
    case "${CONTAINER_LOG_LEVEL,,}" in
        "debug" )
            if [ "${DEBUG_MODE,,}" = "true" ] ; then
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
                    echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${bdm}[DEBUG]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                fi
            else
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
                    echo -e "$(log_prefix)[DEBUG] ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${bdm}[DEBUG]${boff} ** [${PROCESS_NAME}] $1"
                fi
            fi
        ;;
    esac

    case "${CONTAINER_LOG_FILE_LEVEL,,}" in
        "debug" )
            echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
        ;;
    esac
    output_on
}

print_error() {
    output_off
    case "${CONTAINER_LOG_LEVEL,,}" in
        "debug" | "notice" | "warn" | "error")
            if [ "${DEBUG_MODE,,}" = "true" ] ; then
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
                    echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${blr}[ERROR]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                fi
            else
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
                    echo -e "$(log_prefix)[ERROR] ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${blr}[ERROR]${boff} ** [${PROCESS_NAME}] $1"
                fi
            fi
        ;;
    esac

    case "${CONTAINER_LOG_FILE_LEVEL,,}" in
        "debug" | "notice" | "warn" | "error")
            echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
        ;;
    esac
    output_on
}

print_info() {
    output_off
    if [ "${DEBUG_MODE,,}" = "true" ] ; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
            echo -e "$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        else
            echo -e "$(log_prefix)${bdg}[INFO]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        fi
    else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
            echo -e "$(log_prefix)[INFO] ** [${PROCESS_NAME}] $1"
        else
            echo -e "$(log_prefix)${bdg}[INFO]${boff} ** [${PROCESS_NAME}] $1"
        fi
    fi

    echo -e "$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    output_on
}

print_notice() {
    output_off
    case "${CONTAINER_LOG_LEVEL,,}" in
        "debug" | "notice" )
            if [ "${DEBUG_MODE,,}" = "true" ] ; then
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
                    echo -e "$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${bdgy}[NOTICE]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                fi
            else
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
                    echo -e "$(log_prefix)[NOTICE] ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${bdgy}[NOTICE]${boff} ** [${PROCESS_NAME}] $1"
                fi
            fi
        ;;
    esac

    case "${CONTAINER_LOG_FILE_LEVEL,,}" in
        "debug" | "notice" )
            echo -e "$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
        ;;
    esac
    output_on
}

print_start() {
    output_off
    if [ "${CONTAINER_ENABLE_PROCESS_COUNTER,,}" = "true" ] ; then
        if [ -f /tmp/.container/"$(basename $PWD)" ]; then
            proc_start_count=$(cat /tmp/.container/"$(basename $PWD)" | wc -l)
            proc_start_wrapper="[${proc_start_count}] "
        fi

        if [ -z "${proc_start_count}" ] ; then proc_start_count=1 ; fi

        proc_help_arg="$(date +"${CONTAINER_PROCESS_HELPER_DATE_FMT}") $(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") $(basename "$(pwd)") ${proc_start_count} $(cat /etc/hostname)"
        if [ -d "${CONTAINER_PROCESS_HELPER_PATH}" ]; then
            if [ -f "${CONTAINER_PROCESS_HELPER_PATH}"/"$(basename $0)".sh ]; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}"/"$(basename $0)".sh "${proc_help_arg}"
                elif [ -f "${CONTAINER_PROCESS_HELPER_PATH}"/"${CONTAINER_PROCESS_HELPER_SCRIPT}".sh ] ; then
                exec "${CONTAINER_PROCESS_HELPER_PATH}"/"${CONTAINER_PROCESS_HELPER_SCRIPT}".sh "${proc_help_arg}"
            fi
        fi

        if [ "${CONTAINER_PROCESS_RUNAWAY_PROTECTOR,,}" = "true" ] ; then
            if [ "${CONTAINER_PROCESS_RUNAWAY_SHOW_OUTPUT_FINAL,,}" = "true" ] ; then
                if [ "${proc_start_count}" -eq "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ] ; then SHOW_OUTPUT=TRUE ; fi
            fi
            if [ "${proc_start_count}" -gt "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ] ; then
                print_error "POTENTIAL RUNWAY DETECTECTED: Disabling $(basename $PWD) service because it has tried restarting '${CONTAINER_PROCESS_RUNAWAY_LIMIT}' times"
                s6-svc -d /var/run/s6/legacy-services/$(basename "$PWD")
                sleep 3
                exit 1
            fi
            print_debug "[process_restart] - Sleeping for ${CONTAINER_PROCESS_RUNAWAY_DELAY} seconds"
            if [ "${proc_start_count}" -gt 1 ] ; then sleep "${CONTAINER_PROCESS_RUNAWAY_DELAY}" ; fi
        fi
    fi

    if [ "${DEBUG_MODE,,}" = "true" ] ; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
            echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"

        else
            echo -e "$(log_prefix)${bdg}[STARTING]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        fi
        echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1" >> "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
            echo -e "$(log_prefix)[STARTING] ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        else
            echo -e "$(log_prefix)${bdg}[STARTING]${boff} ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
        fi
        echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1" >> "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    fi
    output_on
}

print_warn() {
    output_off
    case "${CONTAINER_LOG_LEVEL,,}" in
        "debug" | "notice" | "warn" )
            if [ "${DEBUG_MODE,,}" = "true" ] ; then
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
                    echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${bdb}[WARN]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
                fi
            else
                if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ] ; then
                    echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1"
                else
                    echo -e "$(log_prefix)${bdb}[WARN]${boff} ** [${PROCESS_NAME}] $1"
                fi
            fi
    esac

    case "${CONTAINER_LOG_FILE_LEVEL,,}" in
        "debug" | "notice" | "warn" )
            echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1" >> "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    esac

    output_on
}

silent() {
    ## Quiet down output
    if [ "${DEBUG_MODE}" = "true" ] || [ "${SHOW_OUTPUT,,}" = "true" ] || [ "${CONTAINER_LOG_LEVEL,,}" = "debug" ] ;  then
        "$@"
    else
        "$@" > /dev/null 2>&1
    fi
}

## Make sure DB is defined
## Old: sanity_db to check DB_USER, DB_PASS, DB_NAME, DB_HOST
## New: sanity_db (dbtype) which will test above or their own unique prefixes to be used with images that have multiuple DB connections
sanity_db() {
    output_off
    if [ -n "$1" ] ; then
        case "${1,,}" in
            "couch" | "couchdb" )
                print_debug "Checking Couch DB Parameters"
                transform_file_var DB_HOST
                if [ -n "${DB_HOST}" ] ; then couch_host=${DB_HOST} ; fi ;
                transform_file_var COUCH_HOST
                if [ -n "${COUCH_HOST}" ] ; then couch_host=${COUCH_HOST} ; fi ;
                if [ -z "${couch_host}" ] ; then
                    print_error "No Couch Database Host Entered! - Set '\$DB_HOST' or '\$COUCH_HOST'"
                    exit 1
                fi
            ;;
            "influx" | "influxdb")
                print_debug "Checking Influx DB Parameters"
                if [ -n "${DB_HOST}" ] ; then influx_host=${DB_HOST} ; fi ;
                transform_file_var DB_HOST
                if [ -n "${INFLUX_HOST}" ] ; then influx_host=${INFLUX_HOST} ; fi ;
                transform_file_var INFLUX_HOST
                if [ -z "${influx_host}" ] ; then
                    print_error "No Influx Database Host Entered! - Set '\$DB_HOST' or '\$INFLUX_HOST'"
                    exit 1
                fi
            ;;
            "mongo" | "mongodb" )
                print_debug "Checking Mongo DB Parameters"
                if [ -n "${DB_HOST}" ] ; then mongo_host=${DB_HOST} ; fi ;
                transform_file_var DB_HOST
                if [ -n "${MONGO_HOST}" ] ; then mongo_host=${MONGO_HOST} ; fi ;
                transform_file_var MONGO_HOST
                if [ -z "${mongo_host}" ] ; then
                    print_error "No Mongo Database Host Entered! - Set '\$DB_HOST' or '\$MONGO_HOST'"
                    exit 1
                fi
            ;;
            "mysql" | "mariadb" )
                print_debug "Checking MariaDB DB Parameters"
                transform_file_var DB_HOST
                if [ -n "${DB_HOST}" ] ; then maria_host=${DB_HOST} ; fi ;
                transform_file_var MYSQL_HOST
                if [ -n "${MYSQL_HOST}" ] ; then maria_host=${MYSQL_HOST} ; fi ;
                transform_file_var MARIA_HOST
                if [ -n "${MARIA_HOST}" ] ; then maria_host=${MARIA_HOST} ; fi ;
                transform_file_var DB_USER
                if [ -n "${DB_USER}" ] ; then maria_user=${DB_USER} ; fi ;
                transform_file_var MYSQL_USER
                if [ -n "${MYSQL_USER}" ] ; then maria_user=${MYSQL_USER} ; fi ;
                transform_file_var MARIA_USER
                if [ -n "${MARIA_USER}" ] ; then maria_user=${MARIA_USER} ; fi ;
                transform_file_var DB_PASS
                if [ -n "${DB_PASS}" ] ; then maria_pass=${DB_PASS} ; fi ;
                transform_file_var MYSQL_PASS
                if [ -n "${MYSQL_PASS}" ] ; then maria_pass=${MYSQL_PASS} ; fi ;
                transform_file_var MARIA_PASS
                if [ -n "${MARIA_PASS}" ] ; then maria_pass=${MARIA_PASS} ; fi ;
                transform_file_var DB_NAME
                if [ -n "${DB_NAME}" ] ; then maria_name=${DB_NAME} ; fi ;
                transform_file_var MYSQL_NAME
                if [ -n "${MYSQL_NAME}" ] ; then maria_name=${MYSQL_NAME} ; fi ;
                transform_file_var MARIA_NAME
                if [ -n "${MARIA_NAME}" ] ; then maria_name=${MARIA_NAME} ; fi ;
                if [ -z "${maria_host}" ] ; then
                    print_error "No MariaDB Database Host Entered! - Set '\$DB_HOST' or '\$MARIA_HOST'"
                    exit 1
                fi
                if [ -z "${maria_name}" ] ; then
                    print_error "No MariaDB Database Name Entered! - Set '\$DB_NAME' or '\$MARIA_NAME'"
                    exit 1
                fi
                if [ -z "${maria_user}" ] ; then
                    print_error "No MariaDB Database USER Entered! - Set '\$DB_USER' or '\$MARIA_USER'"
                    exit 1
                fi
                if [ -z "${maria_pass}" ] ; then
                    print_error "No MariaDB Database Pass Entered! - Set '\$DB_PASS' or '\$MARIA_PASS'"
                    exit 1
                fi
            ;;
            "pgsql" | "psql" | "postgres" | "postgresql" )
                print_debug "Checking Postgres DB Parameters"
                transform_file_var DB_HOST
                if [ -n "${DB_HOST}" ] ; then postgres_host=${DB_HOST} ; fi ;
                transform_file_var POSTGRES_HOST
                if [ -n "${POSTGRES_HOST}" ] ; then postgres_host=${POSTGRES_HOST} ; fi ;
                transform_file_var DB_USER
                if [ -n "${DB_USER}" ] ; then postgres_user=${DB_USER} ; fi ;
                transform_file_var POSTGRES_USER
                if [ -n "${POSTGRES_USER}" ] ; then postgres_user=${POSTGRES_USER} ; fi ;
                transform_file_var DB_PASS
                if [ -n "${DB_PASS}" ] ; then postgres_pass=${DB_PASS} ; fi ;
                transform_file_var PGPASSWORD
                if [ -n "${PGPASSWORD}" ] ; then postgres_pass=${PGPASSWORD} ; fi ;
                transform_file_var DB_NAME
                if [ -n "${DB_NAME}" ] ; then postgres_name=${DB_NAME} ; fi ;
                transform_file_var POSTGRES_NAME
                if [ -n "${POSTGRES_NAME}" ] ; then postgres_name=${POSTGRES_NAME} ; fi ;
                if [ -z "${postgres_host}" ] ; then
                    print_error "No PostgreSQL Database Host Entered! - Set '\$DB_HOST' or '\$POSTGRES_HOST'"
                    exit 1
                fi
                if [ -z "${postgres_name}" ] ; then
                    print_error "No PostgreSQL Database Name Entered! - Set '\$DB_NAME' or '\$POSTGRES_NAME'"
                    exit 1
                fi
                if [ -z "${postgres_user}" ] ; then
                    print_error "No PostgreSQL Database USER Entered! - Set '\$DB_USER' or '\$POSTGRES_USER'"
                    exit 1
                fi
                if [ -z "${postgres_pass}" ] ; then
                    print_error "No PostgreSQL Database Pass Entered! - Set '\$DB_PASS' or '\$POSTGRES_PASS'"
                    exit 1
                fi
            ;;
            "rabbit" | "rabbitmq" )
                transform_file_var DB_HOST
                if [ -n "${DB_HOST}" ] ; then rabbit_host=${DB_HOST} ; fi ;
                transform_file_var RABBIT_HOST
                if [ -n "${RABBIT_HOST}" ] ; then rabbit_host=${RABBIT_HOST} ; fi ;
                transform_file_var RABBITMQ_HOST
                if [ -n "${RABBITMQ_HOST}" ] ; then rabbit_host=${RABBITMQ_HOST} ; fi ;
                if [ -z "${rabbit_host}" ] ; then
                    print_error "No RabbitMQ Database Host Entered! - Set '\$DB_HOST' or '\$RABBIT_HOST'"
                    exit 1
                fi
            ;;
            "redis" )
                print_debug "Checking Redis DB Parameters"
                transform_file_var DB_HOST
                if [ -n "${DB_HOST}" ] ; then redis_host=${DB_HOST} ; fi ;
                transform_file_var REDIS_HOST
                if [ -n "${REDIS_HOST}" ] ; then redis_host=${REDIS_HOST} ; fi ;
                if [ -z "${redis_host}" ] ; then
                    print_error "No Redis Database Host Entered! - Set '\$DB_HOST' or '\$REDIS_HOST'"
                    exit 1
                fi
            ;;
            "rethink" )
                print_debug "Checking RethinkDB DB Parameters"
                transform_file_var DB_HOST
                if [ -n "${DB_HOST}" ] ; then rethink_host=${DB_HOST} ; fi ;
                transform_file_var RETHINK_HOST
                if [ -n "${RETHINK_HOST}" ] ; then rethink_host=${RETHINK_HOST} ; fi ;
                if [ -z "${rethink_host}" ] ; then
                    print_error "No Rethink Database Host Entered! - Set '\$DB_HOST' or '\$RETHINK_HOST'"
                    exit 1
                fi
            ;;
        esac
        output_on
    else
        ## Legacy This will eventually be removed and replaced with this warning
        #print_debug "Skipping DB Checking because it is missing DB_TYPE argument"
        print_debug "Using Legacy db_ready command - please upgrade"
        transform_file_var DB_HOST
        if [ -z "${DB_HOST}" ]; then
            print_error "No Database Host Entered! - Set '\$DB_HOST'"
            exit 1
        fi

        transform_file_var DB_NAME
        if [ -z "${DB_NAME}" ]; then
            print_error "No Database Name Entered! - Set '\$DB_NAME'"
            exit 1
        fi

        transform_file_var DB_USER
        if [ -z "${DB_USER}" ]; then
            print_error "No Database User Entered! - Set '\$DB_USER'"
            exit 1
        fi

        transform_file_var DB_PASS
        if [ -z "${DB_PASS}" ]; then
            print_error "No Database Password Entered! - Set '\$DB_PASS'"
            exit 1
        fi
        output_on
    fi
}

sanity_var() {
    ## Check is Variable is Defined
    ## Usage: sanity_var varname "Description"
    output_off
    print_debug "Looking for existence of $1 environment variable"
    if [ ! -v "$1" ]; then
        print_error "No '$2' Entered! - Set '\$$1'"
        exit 1
    fi
    output_on
}

## Services
service_start() {
    ln -sf /etc/services.available/"${1}" /etc/services.d/
}

service_stop() {
    echo "DONOTSTART added by $(basename \""$0"\")" >> /tmp/.container/"${1}"-init
    #if [ "${1}" != "$(basename "$0")" ] ; then
    #    echo "DONOTSTART added by $(basename \""$0"\")" >> /tmp/.container/"${1}"-init
    #fi
    #DONOTSTART=TRUE
}

set_timezone() {
    ## Timezone Setup
    if [ -f /usr/share/zoneinfo/"${TIMEZONE}" ]; then
        if [ "${TIMEZONE}" != "$(cat /etc/timezone)" ] ; then
            print_notice "Timezone: Setting to '${TIMEZONE}' from '$(cat /etc/timezone)'"
            cp -R /usr/share/zoneinfo/"${1}" /etc/localtime
            echo "${1}" > /etc/timezone
        fi
    else
        print_warn "Timezone: ${TIMEZONE} does not exist - Using '$(cat /etc/timezone)'"
    fi
}

showoff() {
    output_off
    if [ -n "${IMAGE_NAME}" ] ; then
        iv=$(get_image_version)
        is="$(echo 'H4sIAAAAAAAAA/PMTUxPtVLgAgDj9n4BCAAAAA==' | base64 -d | gunzip) ${IMAGE_NAME}"
        if [ ! -z "${iv// }" ] ; then
            is="${is}$(echo 'H4sIAAAAAAAAA1OoUQhLLSrOzM9TUOACAAiVoSgNAAAA' | base64 -d | gunzip)${iv}$(echo 'H4sIAAAAAAAAA1MIqSxIVVDPzE1MT41PzkjMS0/NyU9XV0jLL1JISS1JzMwp5gIAZRrZYCQAAAA=' | base64 -d | gunzip)"
        fi
        is="${is}"
        if [ -n "${IMAGE_REPO_URL}" ] ; then
            ir="$(echo 'H4sIAAAAAAAAAwtKLcgvzizJL6rUd8lPLs1NzStJLMnMz7PiAgAxTVbtGgAAAA==' | base64 -d | gunzip) ${IMAGE_REPO_URL}"
        fi
    fi
    echo "H4sIAAAAAAAAA61RQRLEIAi78wpvXAq971t68CE8vgni2s7urWUGEyRBHVt7JTYzc+Ga4WD+T+Q/pm9jmQNbIZpNN9OOpGSqnA6I4jJlp1RZZ2OZUbrK3B9nxWw5VB9NiOFNCt5ta8s0kSD3suiBxOQDRh0WxSWQcbuYj9Mp4KuksKAoOVm3qlvRfq1Vl4Nj5fkvZnCsnEeFItgXAgAA" | base64 -d | gunzip
    echo "${is}"
    echo "${ir}"
    echo "H4sIAAAAAAAAA/PJTE7NK061UvD1DFGoUTi0UsHIwMhEwSWxLFXBOT+vKL+SCwCc9R6MIwAAAA==" | base64 -d | gunzip
    echo ""
    echo "H4sIAAAAAAAAA22MsRXCMAwF+0zxB4DQ01JRMISIZdDDtowkJy/bkwG46t4Vd8+Itzik0ovRTVdJ7Nh1YKUyGDjjps2PavB+mJq0F+qOTe2DrIZFW0gbnDAlXrlor9zihJDKZcfoiYL9BGoJmSmGMYy/gz18Pu61si1CBT56VwvQSlLoWXieJvzhocfh3rJegXdE9+vlsm3bHGKcNEvMC00/MF6uwtoAAAA=" | base64 -d | gunzip
    echo ""
    output_on
}

truefalse_yesno() {
    ## Convert TRUE or FALSE statements to either yes or no
    ## Usage: 'truefalse_yesno varname'
    ## Don't prefix it with a $
    ## Optionally add "uppercase" / "lowercase" as second value on how you wish it to be replaced
    value=$(set | grep "${1}"= | cut -d '=' -f2)
    var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ] ; then
        print_debug "Converting Variable Name ${var} value to 'yes'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=YES"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=yes"
                ;;
            esac
        else
            export "$1=yes"
        fi
        elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ] ; then
        print_debug "Converting Variable Name ${var} value to 'no'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=NO"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=no"
                ;;
            esac
        else
            export "$1=no"
        fi
    fi
}

update_template() {
    ## Replace placeholders with values
    ## Usage: 'update_template <filename> <varname>
    ## Can have multiple varnames - Don't prefix the varname with $
    ## You can use wildcards if you Quote the first argument eg "*.template"
    template_files=${1}
    templates=$(echo "${template_files}" | tr " " "\n")
    shift
    for template_file in $templates; do

        [[ ! -f "${template_file}" ]] && return 1

        template_variables=($@)
        template_user=$(stat -c %U "${template_file}")
        template_tmp_file=$(mktemp)
        cp -a "${template_file}" "${template_tmp_file}"

        for template_variable in ${template_variables[@]}; do
        # Keep the compatibilty: {{VAR}} => ${VAR}
            sed -ri "s/[{]{2}$template_variable[}]{2}/\${$template_variable}/g" "${template_tmp_file}"
            print_debug "[update_template] Template: '${template_file}' updating field '${template_variable}'"
        done

        # Replace placeholders
        (
            export ${template_variables[@]}
            local IFS=":"; sudo -HEu ${template_user} envsubst "${template_variables[*]/#/$}" < "${template_tmp_file}" > "${template_file}"
        )

        rm -f "${template_tmp_file}"
    done
}

transform_file_var() {
    ## Docker Secrets Support
    ## usage: transform_file_var VAR
    ##    ie: transform_file_var 'XYZ_DB_PASSWORD'
    ##        (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature)
    local variables
    variables=$(echo "$@" | tr " " "\n")
    for variable in $variables; do
        if [ -v "${variable}"_FILE ] ; then
            file_variable=${variable}_FILE
            if [ ! -f "${!file_variable}" ] ; then
                print_error "[transform_file_var] ${variable}_FILE set as environment variable, however file doesn't exist"
                return 1
            fi
            export "${variable}"="$(cat "${!file_variable}")"
        fi
    done
    unset file_variable
    unset variables
}

truefalse_onoff() {
    ## Convert TRUE or FALSE statements to either yes or no
    ## Usage: 'truefalse_yesno varname'
    ## Don't prefix it with a $
    ## Optionally add "uppercase" / "lowercase" as second value on how you wish it to be replaced
    value=$(set | grep "${1}"= | cut -d '=' -f2)
    var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ] ; then
        print_debug "Converting Variable Name ${var} value to 'On'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=ON"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=on"
                ;;
            esac
        else
            export "$1=ON"
        fi
        elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ] ; then
        print_debug "Converting Variable Name ${var} value to 'Off'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=OFF"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=off"
                ;;
            esac
        else
            export "$1=off"
        fi
    fi
}

truefalse_onezero() {
    ## Convert TRUE or FALSE statements to either 1 or 0
    ## Usage: 'truefalse_onezero varname'
    ## Don't prefix it with a $
    value=$(set | grep "${1}"= | cut -d '=' -f2)
    var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ] ; then
        print_debug "Converting Variable Name ${var} value to '1'"
        unset "$1"
        export "$1=1"
        elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ] ; then
        print_debug "Converting Variable Name ${var} value to '0'"
        unset "$1"
        export "$1=0"
    fi
}

var_false() {
    ## Timesaver for if statements
    ## Usage: if var_false $VARNAME ; then ... fi
    [ "${1,,}" = "false" ] || [ "${1,,}" = "no" ]
}

var_notfalse() {
    [ "${1,,}" != "false" ]
}

var_nottrue() {
    [ "${1,,}" != "true" ]
}

var_true() {
    [ "${1,,}" = "true" ] || [ "${1,,}" = "yes" ]
}

wait_for_directory() {
    ## Wait for Directory to exist
    ## Usage: wait_for_directory socketname
    print_debug "Looking for existence of directory: $1"
    while [ ! -d "${1}" ] ; do
        sleep 1
    done
}

wait_for_file() {
    ## Wait for File to exist
    ## Usage: wait_for_file filename
    print_debug "Looking for existence of file: $1"
    while [ ! -f "${1}" ] ; do
        sleep 1
    done
}

wait_for_port() {
    ## Wait for Port to exist
    ## Usage: wait_for_port hostname port
    print_debug "Looking for existence of listening port on $1:$2"
    counter=0
    while ! (nc -z "${1}" "${2}") ; do
        sleep 5
        (( counter+=5 ))
        print_warn "Host '${1}' is not listening on port '${2}', retrying.. ($counter seconds so far)"
    done
}

wait_for_socket() {
    ## Wait for Socket to exist
    ## Usage: wait_for_socket socketname
    print_debug "Looking for existence of socket: $1"
    while [ ! -S "${1}" ] ; do
        sleep 1
    done
}

yesno_truefalse() {
    ## Convert YES or NO statements to either TRUE or FALSE
    ## Usage: 'yesno_truefalse varname'
    ## Don't prefix it with a $
    ## Optionally add "uppercase" / "lowercase" as second value on how you wish it to be replaced
    value=$(set | grep "${1}"= | cut -d '=' -f2)
    var=$(set | grep "${1}"= | sed "s/=.*//g")

    if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ] ; then
        print_debug "Converting Variable Name ${var} value to 'yes'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "${2,,}" in
                "uppercase" | "upper" | "uc" )
                    export "$1=TRUE"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=true"
                ;;
            esac
        else
            export "$1=TRUE"
        fi
        elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ] ; then
        print_debug "Converting Variable Name ${var} value to 'no'"
        unset "$1"
        if [ -n "$2" ] ; then
            case "$2" in
                "uppercase" | "upper" | "uc" )
                    export "$1=FALSE"
                ;;
                "lowercase" | "lower" | "lc" )
                    export "$1=false"
                ;;
            esac
        else
            export "$1=FALSE"
        fi
    fi
}

## Keep this last
case "${DEBUG_MODE}" in
    "TRUE" | "true" | "YES" | "yes" | "ON" | "on" )
        CONTAINER_LOG_LEVEL="DEBUG"
        set -x
    ;;
    "FALSE" | "false" | "NO" | "no" | "OFF" | "off" )
        :
    ;;
    * )
        if [ "$(dirname "$0")" = "/var/run/s6/etc/cont-init.d" ] || [ "$(dirname "$0")" = "/etc/cont-init.d" ]; then
            if [ "${DEBUG_MODE}" = "$(basename \""$0"\")" ] ; then
                print_notice "Enabling Debug mode for $(basename \""$0"\") scripts"
                set -x
            fi
        fi
        if [ "${DEBUG_MODE}" = "$(basename "$PWD")" ] ; then
            print_notice "Enabling Debug mode for $(basename "$PWD") scripts"
            set -x
        fi

    ;;
esac
